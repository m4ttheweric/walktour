{"mappings":"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","sources":["src/index.ts","src/components/Mask.tsx","src/utils/viewport.ts","src/utils/dom.ts","src/utils/constants.ts","src/utils/positioning.ts","src/utils/offset.ts","src/components/Walktour.tsx","src/utils/scroll.ts","src/utils/tour.ts","src/components/Tooltip.tsx","src/defaultstyles.ts"],"sourcesContent":["import { Mask, type MaskOptions } from \"./components/Mask\";\nimport type {\n  Step,\n  WalktourLogic,\n  WalktourOptions,\n  WalktourProps,\n} from \"./components/Walktour\";\nimport { Walktour } from \"./components/Walktour\";\nimport type { Coords, Dims, ElementInfo } from \"./utils/dom\";\nimport { CardinalOrientation } from \"./utils/positioning\";\n\nexport { Mask, Walktour };\n\nexport {\n  CardinalOrientation,\n  Coords,\n  Dims,\n  ElementInfo,\n  MaskOptions,\n  Step,\n  WalktourLogic,\n  WalktourOptions,\n  WalktourProps,\n};\n","import * as React from 'react';\n\nimport { Coords, Dims, ElementInfo } from '../utils/dom';\nimport { getViewportScrollDims } from '../utils/viewport';\n\nexport interface MaskOptions {\n  targetInfo?: ElementInfo;\n  padding: number;\n  radius: number;\n  close: () => void;\n  tourRoot: Element;\n  disableMaskInteraction?: boolean;\n  disableCloseOnClick?: boolean;\n  maskId: string;\n  maskFill?: string;\n}\n\nexport function Mask(props: MaskOptions): JSX.Element {\n  const {\n    targetInfo,\n    disableMaskInteraction,\n    padding,\n    radius,\n    tourRoot,\n    close,\n    disableCloseOnClick,\n    maskId,\n    maskFill,\n  } = props;\n  const { width: containerWidth, height: containerHeight } =\n    getViewportScrollDims(tourRoot);\n  const pathId = `clip-path-${maskId}`;\n\n  const getCutoutPath = (target?: { coords: Coords; dims: Dims }): string => {\n    if (!target) {\n      return '';\n    }\n\n    const { dims, coords } = target;\n\n    const cutoutTop: number = coords.y - padding;\n    const cutoutLeft: number = coords.x - padding;\n    const cutoutRight: number = coords.x + dims.width + padding;\n    const cutoutBottom: number = coords.y + dims.height + padding;\n\n    if (radius > 0) {\n      return `M 0, 0\n              L 0, ${containerHeight}\n              L ${cutoutLeft}, ${containerHeight}\n              L ${cutoutLeft}, ${cutoutTop + radius}\n              Q ${cutoutLeft}, ${cutoutTop}, ${\n                cutoutLeft + radius\n              }, ${cutoutTop}\n              L ${cutoutRight - radius}, ${cutoutTop}\n              Q ${cutoutRight}, ${cutoutTop}, ${cutoutRight}, ${\n                cutoutTop + radius\n              }\n              L ${cutoutRight}, ${cutoutBottom - radius}\n              Q ${cutoutRight}, ${cutoutBottom}, ${\n                cutoutRight - radius\n              }, ${cutoutBottom}\n              L ${cutoutLeft + radius}, ${cutoutBottom}\n              Q ${cutoutLeft}, ${cutoutBottom}, ${cutoutLeft}, ${\n                cutoutBottom - radius\n              }\n              L ${cutoutLeft}, ${containerHeight}\n              L ${containerWidth}, ${containerHeight}\n              L ${containerWidth}, 0`;\n    }\n\n    return `M 0, 0\n            L 0, ${containerHeight}\n            L ${cutoutLeft}, ${containerHeight}\n            L ${cutoutLeft}, ${cutoutTop}\n            L ${cutoutRight}, ${cutoutTop}\n            L ${cutoutRight}, ${cutoutBottom}\n            L ${cutoutLeft}, ${cutoutBottom}\n            L ${cutoutLeft}, ${containerHeight}\n            L ${containerWidth}, ${containerHeight}\n            L ${containerWidth}, 0`;\n  };\n\n  const svgStyle: React.CSSProperties = {\n    height: containerHeight,\n    width: containerWidth,\n    pointerEvents: disableMaskInteraction ? 'auto' : 'none',\n  };\n\n  return (\n    <svg style={svgStyle}>\n      {targetInfo && (\n        <defs>\n          <clipPath id={pathId}>\n            <path d={getCutoutPath(targetInfo)} />\n          </clipPath>\n        </defs>\n      )}\n\n      <rect\n        onClick={disableCloseOnClick ? undefined : close}\n        x={0}\n        y={0}\n        width={containerWidth}\n        height={containerHeight}\n        fill={maskFill ?? 'black'}\n        fillOpacity={0.3}\n        pointerEvents=\"auto\"\n        clipPath={targetInfo ? `url(#${pathId})` : undefined}\n      />\n    </svg>\n  );\n}\n","import {\n  Coords,\n  Dims,\n  getElementCoords,\n  getElementDims,\n  isDefaultScrollingElement,\n  isWithinAt,\n} from './dom';\nimport { addAppropriateOffset, getCurrentScrollOffset } from './offset';\n\nexport function getViewportHeight(root: Element): number {\n  return root.clientHeight;\n}\n\nexport function getViewportWidth(root: Element): number {\n  return root.clientWidth;\n}\n\nexport function getViewportDims(root: Element): Dims {\n  return {\n    width: getViewportWidth(root),\n    height: getViewportHeight(root),\n  };\n}\n\nexport function getViewportScrollHeight(root: Element): number {\n  return root.scrollHeight;\n}\n\nexport function getViewportScrollWidth(root: Element): number {\n  return root.scrollWidth;\n}\n\nexport function getViewportScrollDims(root: Element): Dims {\n  return {\n    width: getViewportScrollWidth(root),\n    height: getViewportScrollHeight(root),\n  };\n}\n\nexport function getViewportStart(root: Element): Coords {\n  if (isDefaultScrollingElement(root)) {\n    return {\n      x: 0,\n      y: 0,\n    };\n  } else {\n    return getElementCoords(root);\n  }\n}\n\nexport function getViewportEnd(root: Element): Coords {\n  const startCoords: Coords = getViewportStart(root);\n  return {\n    x: startCoords.x + getViewportWidth(root),\n    y: startCoords.y + getViewportHeight(root),\n  };\n}\n\nexport function getViewportScrollStart(root: Element): Coords {\n  const curScrollOffset: Coords = getCurrentScrollOffset(root);\n  const start: Coords = getViewportStart(root);\n\n  return {\n    x: start.x - curScrollOffset.x,\n    y: start.y - curScrollOffset.y,\n  };\n}\n\nexport function getViewportScrollEnd(root: Element): Coords {\n  const startCoords: Coords = getViewportScrollStart(root);\n  const { width, height } = getViewportScrollDims(root);\n  return {\n    x: startCoords.x + width,\n    y: startCoords.y + height,\n  };\n}\n\nexport function isElementInView(\n  root: Element,\n  element: HTMLElement,\n  atPosition?: Coords,\n  needsAdjusting?: boolean\n): boolean {\n  if (!root || !element) {\n    return false;\n  }\n  const explicitPosition: Coords =\n    atPosition &&\n    (needsAdjusting ? addAppropriateOffset(root, atPosition) : atPosition);\n  const position: Coords =\n    explicitPosition || addAppropriateOffset(root, getElementCoords(element));\n  const elementDims: Dims = getElementDims(element);\n  const startCoords: Coords = addAppropriateOffset(\n    root,\n    getViewportStart(root)\n  );\n  const viewportDims: Dims = getViewportDims(root);\n\n  return isWithinAt(elementDims, viewportDims, position, startCoords);\n}\n\n// if directed to scroll to a position which is outside the bounds of the scrolling container, the\n// viewport will stop at the edges of that container. We want to get the coords that the viewport\n// will end up when given certain coords\nexport function getScrolledViewportPosition(\n  root: Element,\n  scrollDestination: Coords\n) {\n  const dims = getViewportDims(root);\n  const startCoords = getViewportScrollStart(root);\n  const endCoords = getViewportScrollEnd(root);\n\n  const rightmost = endCoords.x - dims.width;\n  const bottommost = endCoords.y - dims.height;\n\n  let coords: Coords = scrollDestination;\n\n  if (scrollDestination.x < startCoords.x) {\n    coords.x = startCoords.x;\n  } else if (scrollDestination.x > rightmost) {\n    coords.x = rightmost;\n  } else {\n    coords.x = scrollDestination.x;\n  }\n\n  if (scrollDestination.y < startCoords.y) {\n    coords.y = startCoords.y;\n  } else if (scrollDestination.y > bottommost) {\n    coords.y = bottommost;\n  } else {\n    coords.y = scrollDestination.y;\n  }\n\n  return coords;\n}\n","import { focusableSelector } from './constants';\nimport { getTargetPosition } from './positioning';\n\nexport interface Coords {\n  x: number;\n  y: number;\n}\n\nexport interface Dims {\n  width: number;\n  height: number;\n}\n\nexport interface ElementInfo {\n  dims: Dims;\n  coords: Coords;\n}\n\nexport function isValidCoords(coords: Coords): boolean {\n  if (!coords) {\n    return false;\n  } else if ((!coords.x && coords.x !== 0) || (!coords.y && coords.y !== 0)) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function isValidDims(dims: Dims): boolean {\n  if (!dims) {\n    return false;\n  } else if (\n    (!dims.height && dims.height !== 0) ||\n    (!dims.width && dims.height !== 0)\n  ) {\n    return false;\n  } else if (dims.height < 0 || dims.width < 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nexport function dist(a: Coords, b: Coords): number {\n  if (!isValidCoords(a) || !isValidCoords(b)) {\n    return;\n  }\n\n  return Math.sqrt(\n    Math.pow(Math.abs(a.x - b.x), 2) + Math.pow(Math.abs(a.y - b.y), 2)\n  );\n}\n\nexport function areaDiff(a: Dims, b: Dims): number {\n  if (!isValidDims(a) || !isValidDims(b)) {\n    return;\n  }\n\n  return Math.abs(a.height * a.width - b.height * b.width);\n}\n\nexport function getElementCoords(element: Element): Coords {\n  if (!element) {\n    return;\n  }\n  const elementData: ClientRect = element.getBoundingClientRect();\n  return {\n    x: elementData.left,\n    y: elementData.top,\n  };\n}\n\nexport function getElementDims(element: Element): Dims {\n  if (!element) {\n    return;\n  }\n  const elementData = element.getBoundingClientRect();\n  return {\n    width: elementData.width,\n    height: elementData.height,\n  };\n}\n\n//https://gist.github.com/gre/296291b8ce0d8fe6e1c3ea4f1d1c5c3b\nexport function getNearestScrollAncestor(element: Element): Element {\n  const regex = /(auto|scroll)/;\n\n  const style = (el: Element, prop: string) =>\n    getComputedStyle(el, null).getPropertyValue(prop);\n\n  const scroll = (el: Element) =>\n    regex.test(\n      style(el, 'overflow') + style(el, 'overflow-y') + style(el, 'overflow-x')\n    );\n\n  if (!element || isDefaultScrollingElement(element)) {\n    return getDefaultScrollingElement();\n  } else {\n    if (scroll(element)) {\n      return element;\n    } else {\n      return getNearestScrollAncestor(element.parentElement);\n    }\n  }\n}\n\n//https://github.com/GreenGremlin/scroll-doc/blob/master/index.js\nexport function getDefaultScrollingElement(): Element {\n  const windowStart: number = window.pageYOffset; //slightly better support than scrollY\n  document.documentElement.scrollTop = windowStart + 1;\n  if (window.pageXOffset > windowStart) {\n    document.documentElement.scrollTop = windowStart; //reset\n    return document.documentElement;\n  } else {\n    return document.scrollingElement || document.body;\n  }\n}\n\nexport function isDefaultScrollingElement(root: Element) {\n  return (\n    root.isSameNode(document.body) ||\n    root.isSameNode(document.scrollingElement) ||\n    root.isSameNode(document.documentElement)\n  );\n}\n\n//if we're not putting the portal in a custom container, it needs to be at the body level\nexport function getValidPortalRoot(root: Element) {\n  // check for the potential default scrolling elements that might be returned from the above function\n  if (isDefaultScrollingElement(root)) {\n    return document.body;\n  } else {\n    return root;\n  }\n}\n\nexport function getCombinedData(\n  aCoords: Coords,\n  aDims: Dims,\n  bCoords: Coords,\n  bDims: Dims\n): { coords: Coords; dims: Dims } {\n  // generates similar data as getBoundingClientRect but using hypothetical positions\n  const generateBounds = (\n    coords: Coords,\n    dims: Dims\n  ): { left: number; right: number; top: number; bottom: number } => {\n    return {\n      left: coords.x,\n      right: coords.x + dims.width,\n      top: coords.y,\n      bottom: coords.y + dims.height,\n    };\n  };\n\n  const mostExtreme = (a: number, b: number, largest: boolean): number => {\n    return a > b ? (largest ? a : b) : largest ? b : a;\n  };\n\n  const aBounds = generateBounds(aCoords, aDims);\n  const bBounds = generateBounds(bCoords, bDims);\n\n  const left: number = mostExtreme(aBounds.left, bBounds.left, false);\n  const right: number = mostExtreme(aBounds.right, bBounds.right, true);\n  const top: number = mostExtreme(aBounds.top, bBounds.top, false);\n  const bottom: number = mostExtreme(aBounds.bottom, bBounds.bottom, true);\n\n  return {\n    coords: {\n      x: left,\n      y: top,\n    },\n    dims: {\n      height: bottom - top,\n      width: right - left,\n    },\n  };\n}\n\n// determines if a can fit within b\nexport function fitsWithin(aDims: Dims, bDims: Dims) {\n  if (!isValidDims(aDims) || !isValidDims(bDims)) {\n    return false;\n  }\n\n  return aDims.height <= bDims.height && aDims.width <= bDims.width;\n}\n\n// determines if a does fit within b at the given coords\nexport function isWithinAt(\n  aDims: Dims,\n  bDims: Dims,\n  aCoords?: Coords,\n  bCoords?: Coords\n) {\n  if (!isValidDims(aDims) || !isValidDims(bDims)) {\n    return false;\n  }\n\n  const validCoordsA: Coords = isValidCoords(aCoords)\n    ? aCoords\n    : { x: 0, y: 0 };\n  const validCoordsB: Coords = isValidCoords(bCoords)\n    ? bCoords\n    : { x: 0, y: 0 };\n  const fitsDims: boolean = fitsWithin(aDims, bDims);\n  const fitsHorizontally: boolean =\n    validCoordsA.x >= validCoordsB.x &&\n    validCoordsA.x + aDims.width <= validCoordsB.x + bDims.width;\n  const fitsVertically: boolean =\n    validCoordsA.y >= validCoordsB.y &&\n    validCoordsA.y + aDims.height <= validCoordsB.y + bDims.height;\n\n  return fitsDims && fitsHorizontally && fitsVertically;\n}\n\nexport function getFocusableElements(\n  root: Element,\n  includeSelf?: boolean\n): HTMLElement[] {\n  const focusableChildren = root.querySelectorAll(focusableSelector);\n  let array: HTMLElement[] = [];\n  if (includeSelf && root.matches(focusableSelector)) {\n    array.push(root as HTMLElement);\n  }\n  if (focusableChildren.length > 0) {\n    focusableChildren.forEach(el => array.push(el as HTMLElement));\n  }\n\n  return array;\n}\n\n// helper function to get first/last focusable elements if possible\nexport function getEdgeFocusables(\n  defaultElement: HTMLElement,\n  container?: HTMLElement,\n  includeSelf?: boolean\n): { start: HTMLElement; end: HTMLElement } {\n  if (container) {\n    const containerFocusables: HTMLElement[] = getFocusableElements(\n      container,\n      includeSelf\n    );\n    if (containerFocusables.length > 0) {\n      return {\n        start: containerFocusables[0],\n        end: containerFocusables[containerFocusables.length - 1],\n      };\n    }\n  }\n\n  return {\n    start: defaultElement,\n    end: defaultElement,\n  };\n}\n\nexport function getTargetInfo(\n  root: Element,\n  target?: HTMLElement\n): ElementInfo | undefined {\n  if (!root || !target) {\n    return;\n  }\n  const dims: Dims = getElementDims(target);\n  const coords: Coords = getTargetPosition(root, target);\n\n  return {\n    coords,\n    dims,\n  };\n}\n\nexport function isForeignTarget(root: Element, selector: string): boolean {\n  return !root.querySelector(selector);\n}\n","export const TAB_KEYCODE = 9;\n\n//  selector adapted from https://gist.github.com/r3lk3r/0030bab99347a2326334e00b23188cab#file-focusloopingutil-js\nexport const focusableSelector: string =\n  'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, [tabindex]:not([tabindex^=\"-\"]):not([disabled]), [contenteditable]';\n","import {\n  Coords,\n  Dims,\n  dist,\n  fitsWithin,\n  getCombinedData,\n  getElementCoords,\n  getElementDims,\n  isForeignTarget,\n  isWithinAt,\n} from './dom';\nimport {\n  addAppropriateOffset,\n  applyCenterOffset,\n  centerViewportAroundElement,\n  centerViewportAroundElements,\n  getCurrentScrollOffset,\n  getViewportCenter,\n} from './offset';\nimport {\n  getScrolledViewportPosition,\n  getViewportDims,\n  getViewportScrollEnd,\n  getViewportScrollStart,\n  getViewportStart,\n  isElementInView,\n} from './viewport';\n\nexport enum CardinalOrientation {\n  EAST = 'east',\n  SOUTH = 'south',\n  WEST = 'west',\n  NORTH = 'north',\n  CENTER = 'center',\n  EASTNORTH = 'east-north',\n  EASTSOUTH = 'east-south',\n  SOUTHEAST = 'south-east',\n  SOUTHWEST = 'south-west',\n  WESTSOUTH = 'west-south',\n  WESTNORTH = 'west-north',\n  NORTHWEST = 'north-west',\n  NORTHEAST = 'north-east',\n}\n\nexport interface OrientationCoords {\n  orientation: CardinalOrientation;\n  coords: Coords;\n}\n\nexport interface GetTooltipPositionArgs {\n  target: HTMLElement;\n  tooltip: HTMLElement;\n  padding: number;\n  tooltipSeparation: number;\n  root: Element;\n  orientationPreferences?: CardinalOrientation[];\n  getPositionFromCandidates?: (\n    candidates: OrientationCoords[]\n  ) => OrientationCoords;\n  disableAutoScroll?: boolean;\n  allowForeignTarget?: boolean;\n  selector?: string;\n}\n\nfunction getTooltipPositionCandidates(\n  target: HTMLElement,\n  tooltip: HTMLElement,\n  padding: number,\n  tooltipDistance: number,\n  includeAllPositions?: boolean\n): OrientationCoords[] {\n  if (!target || !tooltip) {\n    return;\n  }\n\n  const tooltipDims: Dims = getElementDims(tooltip);\n  const targetCoords: Coords = getElementCoords(target);\n  const targetDims: Dims = getElementDims(target);\n  const centerX: number =\n    targetCoords.x - (tooltipDims.width - targetDims.width) / 2;\n  const centerY: number =\n    targetCoords.y - (tooltipDims.height - targetDims.height) / 2;\n  const eastOffset: number =\n    targetCoords.x + targetDims.width + padding + tooltipDistance;\n  const southOffset: number =\n    targetCoords.y + targetDims.height + padding + tooltipDistance;\n  const westOffset: number =\n    targetCoords.x - tooltipDims.width - padding - tooltipDistance;\n  const northOffset: number =\n    targetCoords.y - tooltipDims.height - padding - tooltipDistance;\n\n  const east: Coords = { x: eastOffset, y: centerY };\n  const south: Coords = { x: centerX, y: southOffset };\n  const west: Coords = { x: westOffset, y: centerY };\n  const north: Coords = { x: centerX, y: northOffset };\n  const center: Coords = applyCenterOffset(\n    targetCoords,\n    targetDims,\n    tooltipDims\n  );\n\n  const standardPositions = [\n    { orientation: CardinalOrientation.EAST, coords: east },\n    { orientation: CardinalOrientation.SOUTH, coords: south },\n    { orientation: CardinalOrientation.WEST, coords: west },\n    { orientation: CardinalOrientation.NORTH, coords: north },\n  ];\n\n  let additionalPositions: OrientationCoords[];\n  if (includeAllPositions) {\n    const eastAlign: number =\n      targetCoords.x - (tooltipDims.width - targetDims.width) + padding;\n    const southAlign: number =\n      targetCoords.y - (tooltipDims.height - targetDims.height) + padding;\n    const westAlign: number = targetCoords.x - padding;\n    const northAlign: number = targetCoords.y - padding;\n\n    const eastNorth: Coords = { x: eastOffset, y: northAlign };\n    const eastSouth: Coords = { x: eastOffset, y: southAlign };\n    const southEast: Coords = { x: eastAlign, y: southOffset };\n    const southWest: Coords = { x: westAlign, y: southOffset };\n    const westSouth: Coords = { x: westOffset, y: southAlign };\n    const westNorth: Coords = { x: westOffset, y: northAlign };\n    const northWest: Coords = { x: westAlign, y: northOffset };\n    const northEast: Coords = { x: eastAlign, y: northOffset };\n\n    additionalPositions = [\n      { orientation: CardinalOrientation.EASTNORTH, coords: eastNorth },\n      { orientation: CardinalOrientation.EASTSOUTH, coords: eastSouth },\n      { orientation: CardinalOrientation.SOUTHEAST, coords: southEast },\n      { orientation: CardinalOrientation.SOUTHWEST, coords: southWest },\n      { orientation: CardinalOrientation.WESTSOUTH, coords: westSouth },\n      { orientation: CardinalOrientation.WESTNORTH, coords: westNorth },\n      { orientation: CardinalOrientation.NORTHWEST, coords: northWest },\n      { orientation: CardinalOrientation.NORTHEAST, coords: northEast },\n    ];\n  }\n\n  return [\n    ...standardPositions,\n    ...additionalPositions,\n    { orientation: CardinalOrientation.CENTER, coords: center },\n  ];\n}\n\n// simple reducer who selects for coordinates closest to the current center of the viewport\nfunction getCenterReducer(\n  root: Element,\n  tooltip: HTMLElement,\n  target: HTMLElement,\n  predictViewport?: boolean\n): (\n  acc: OrientationCoords,\n  cur: OrientationCoords,\n  ind: number,\n  arr: OrientationCoords[]\n) => OrientationCoords {\n  const currentCenter: Coords = getViewportCenter(root, tooltip);\n\n  // store the center of the predicted viewport location with the tooltip at acc\n  // to have a meaningful distance comparison\n  let accCenter: Coords = currentCenter;\n\n  const getCenter = (coords: Coords) => {\n    if (\n      predictViewport &&\n      (!isElementInView(root, target) ||\n        !isElementInView(root, tooltip, coords, true))\n    ) {\n      return getViewportCenter(\n        root,\n        tooltip,\n        getScrolledViewportPosition(\n          root,\n          centerViewportAroundElements(root, tooltip, target, coords)\n        )\n      );\n    } else {\n      return currentCenter;\n    }\n  };\n\n  return (\n    acc: OrientationCoords,\n    cur: OrientationCoords,\n    ind: number,\n    arr: OrientationCoords[]\n  ): OrientationCoords => {\n    if (cur.orientation === CardinalOrientation.CENTER) {\n      //ignore centered coords since those will always be closest to the center\n      if (ind === arr.length - 1 && acc === undefined) {\n        //unless  we're at the end and we still haven't picked a coord\n        return cur;\n      } else {\n        return acc;\n      }\n    } else if (acc === undefined) {\n      accCenter = getCenter(cur.coords);\n      return cur;\n    } else {\n      const center: Coords = getCenter(cur.coords);\n\n      if (dist(center, cur.coords) > dist(accCenter, acc.coords)) {\n        return acc;\n      } else {\n        accCenter = center;\n        return cur;\n      }\n    }\n  };\n}\n\n// complex candidate reducer function that tries to place the tooltip as close to the center of the\n// screen as possible, even after the screen has scrolled to a particular location.\nfunction chooseBestTooltipPosition(\n  preferredCandidates: OrientationCoords[],\n  root: Element,\n  tooltip: HTMLElement,\n  target: HTMLElement,\n  scrollDisabled: boolean\n): OrientationCoords {\n  if (preferredCandidates.length === 1) {\n    //if there's only a single pref candidate, use that\n    return preferredCandidates[0];\n  } else if (scrollDisabled) {\n    // if scrolling is disabled, there's not much we can do except use the naive center reducer\n    return preferredCandidates.reduce(\n      getCenterReducer(root, tooltip, target, false),\n      undefined\n    );\n  } else {\n    // scrolling is allowed, which means we have to figure out:\n    // 1. what candidates are valid positions (not out of the scrolling root's bounds)\n    // 2. which positions are absolutely compatible (allow both target & tooltip to fit within the viewport at the same time)\n    // 3. which positions are currently compatible (allow both target & tooltip to fit with the CURRENT viewport)\n    // 4. which of those positions is *best* - use same closest-to-center heuristic.\n    // priority is 3 > 2 > 1 for the pool of positions from which 4 is chosen\n\n    const viewportDims: Dims = getViewportDims(root);\n    const viewportScrollStart: Coords = getViewportScrollStart(root);\n    const viewportCurrentStart: Coords = getViewportStart(root);\n    const viewportScrollEnd: Coords = getViewportScrollEnd(root);\n    const tooltipDims: Dims = getElementDims(tooltip);\n    const targetDims: Dims = getElementDims(target);\n    const targetCoords: Coords = getElementCoords(target);\n    const curriedGetCombinedData = (coords: Coords) =>\n      getCombinedData(coords, tooltipDims, targetCoords, targetDims);\n\n    const validPositions: OrientationCoords[] = preferredCandidates.filter(\n      getInBoundsFilter(tooltipDims, viewportScrollStart, viewportScrollEnd)\n    );\n    const absoluteCompatiblePositions: OrientationCoords[] =\n      validPositions.filter(\n        getAbsoluteCompatibleArrangementFilter(\n          curriedGetCombinedData,\n          viewportDims\n        )\n      );\n    const currentCompatiblePositions: OrientationCoords[] =\n      absoluteCompatiblePositions.filter(\n        getCurrentInViewFilter(\n          curriedGetCombinedData,\n          viewportDims,\n          viewportCurrentStart\n        )\n      );\n\n    // // if possible, use only those positions which don't force a scroll. Default back to those which can fit in the viewport, even if that means scrolling\n    const compatiblePositions: OrientationCoords[] =\n      currentCompatiblePositions.length > 0\n        ? currentCompatiblePositions\n        : absoluteCompatiblePositions;\n\n    // if there are NO compatible positions, the viewport is too small to accomodate both the target/tooltip, in any arrangement.\n    // we default to our valid positions, even if that means placing the elements slightly off screen.\n    const filteredList =\n      compatiblePositions.length > 0 ? compatiblePositions : validPositions;\n\n    return filteredList.reduce(\n      getCenterReducer(root, tooltip, target, true),\n      undefined\n    );\n  }\n}\n\n// filter out any positions which would have the tooltip be out of the bounds of the root container\n// (i.e. in a position that the viewport can't \"reach\"/scroll to)\nfunction getInBoundsFilter(\n  tooltipDims: Dims,\n  viewportScrollStart: Coords,\n  viewportScrollEnd: Coords\n): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n    return !(\n      coords.x < viewportScrollStart.x ||\n      coords.y < viewportScrollStart.y ||\n      coords.x + tooltipDims.width > viewportScrollEnd.x ||\n      coords.y + tooltipDims.height > viewportScrollEnd.y\n    );\n  };\n}\n\n// filters out any positions which would cause the target/tooltip to not fit within the viewport\nfunction getAbsoluteCompatibleArrangementFilter(\n  curriedGetCombinedData: (coords: Coords) => { dims: Dims; coords: Coords },\n  viewportDims: Dims\n): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n    // we only care about the resultant dims but the input coords are critical here\n    const { dims: combinedDims } = curriedGetCombinedData(coords);\n\n    return fitsWithin(combinedDims, viewportDims);\n  };\n}\n\nfunction getCurrentInViewFilter(\n  curriedGetCombinedData: (coords: Coords) => { dims: Dims; coords: Coords },\n  viewportDims: Dims,\n  viewportCurrentStart: Coords\n): (oc: OrientationCoords) => boolean {\n  return (oc: OrientationCoords): boolean => {\n    const coords: Coords = oc.coords;\n\n    const { dims: combinedDims, coords: combinedCoords } =\n      curriedGetCombinedData(coords);\n\n    return isWithinAt(\n      combinedDims,\n      viewportDims,\n      combinedCoords,\n      viewportCurrentStart\n    );\n  };\n}\n\nfunction getPreferredCandidates(\n  candidates: OrientationCoords[],\n  orientationPreferences?: CardinalOrientation[]\n): OrientationCoords[] {\n  if (!orientationPreferences || orientationPreferences.length === 0) {\n    return candidates;\n  } else if (orientationPreferences.length === 1) {\n    const specifiedCandidate = candidates.find(\n      (oc: OrientationCoords) => oc.orientation === orientationPreferences[0]\n    );\n    if (specifiedCandidate) {\n      return [specifiedCandidate];\n    } else {\n      return candidates; // if the specified orientation isn't available for whatever reason, default to standard behavior\n    }\n  } else {\n    const preferenceFilter = (cc: OrientationCoords) =>\n      orientationPreferences.indexOf(cc.orientation) !== -1;\n    return candidates.filter(preferenceFilter);\n  }\n}\n\nfunction restrictToCurrentViewport(\n  root: Element,\n  coords: Coords,\n  dims: Dims,\n  padding: number\n): Coords {\n  if (!root) {\n    return coords;\n  }\n\n  const viewportStart: Coords = getCurrentScrollOffset(root);\n  const viewportDims: Dims = getViewportDims(root);\n  const viewportEnd: Coords = {\n    x: viewportStart.x + viewportDims.width,\n    y: viewportStart.y + viewportDims.height,\n  };\n  const sx = viewportStart.x + padding;\n  const sy = viewportStart.y + padding;\n  const ex = viewportEnd.x - dims.width - padding;\n  const ey = viewportEnd.y - dims.height - padding;\n\n  let x: number = coords.x;\n  let y: number = coords.y;\n\n  if (coords.x < sx) {\n    x = sx;\n  } else if (coords.x + dims.width > ex) {\n    x = ex;\n  }\n\n  if (coords.y < sy) {\n    y = sy;\n  } else if (coords.y + dims.height > ey) {\n    y = ey;\n  }\n\n  return { x, y };\n}\n\nexport function getTooltipPosition(\n  args: GetTooltipPositionArgs\n): OrientationCoords {\n  const {\n    target,\n    tooltip,\n    padding,\n    tooltipSeparation,\n    orientationPreferences,\n    getPositionFromCandidates,\n    root: tourRoot,\n    disableAutoScroll: scrollDisabled,\n    allowForeignTarget,\n    selector,\n  } = args;\n  const center: Coords = target\n    ? getViewportCenter(\n        tourRoot,\n        tooltip,\n        getScrolledViewportPosition(\n          tourRoot,\n          centerViewportAroundElement(tourRoot, target)\n        )\n      )\n    : getViewportCenter(tourRoot, tooltip);\n  const defaultPosition: Coords = addAppropriateOffset(tourRoot, center);\n\n  if (!tooltip || !tourRoot) {\n    return;\n  }\n\n  if (!target) {\n    return { orientation: null, coords: defaultPosition };\n  }\n\n  const foreignTarget: boolean =\n    allowForeignTarget && isForeignTarget(tourRoot, selector);\n  const noScroll: boolean = scrollDisabled || foreignTarget;\n  const candidates: OrientationCoords[] = getTooltipPositionCandidates(\n    target,\n    tooltip,\n    padding,\n    tooltipSeparation,\n    true\n  );\n  const choosePosition =\n    getPositionFromCandidates ||\n    ((cans: OrientationCoords[]) =>\n      chooseBestTooltipPosition(cans, tourRoot, tooltip, target, noScroll));\n\n  const rawPosition: OrientationCoords = choosePosition(\n    getPreferredCandidates(candidates, orientationPreferences)\n  ); //position relative to current viewport\n\n  if (!rawPosition) {\n    return { orientation: CardinalOrientation.CENTER, coords: defaultPosition };\n  }\n\n  const adjustedPosition: OrientationCoords = {\n    orientation: rawPosition.orientation,\n    coords: addAppropriateOffset(tourRoot, rawPosition.coords),\n  };\n\n  if (foreignTarget) {\n    return {\n      orientation: adjustedPosition.orientation,\n      coords: restrictToCurrentViewport(\n        tourRoot,\n        adjustedPosition.coords,\n        getElementDims(tooltip),\n        padding + tooltipSeparation\n      ),\n    };\n  }\n\n  return adjustedPosition;\n}\n\nexport function getTargetPosition(root: Element, target: HTMLElement): Coords {\n  return addAppropriateOffset(root, getElementCoords(target));\n}\n","import {\n  Coords,\n  Dims,\n  getCombinedData,\n  getElementCoords,\n  getElementDims,\n  isDefaultScrollingElement,\n} from './dom';\nimport { getViewportDims, getViewportStart } from './viewport';\n\nexport function getCurrentScrollOffset(root: Element): Coords {\n  return {\n    x: root.scrollLeft,\n    y: root.scrollTop,\n  };\n}\n\nexport function addScrollOffset(root: Element, coords: Coords) {\n  const curOffset: Coords = getCurrentScrollOffset(root);\n  return {\n    x: coords.x + curOffset.x,\n    y: coords.y + curOffset.y,\n  };\n}\n\nexport function addAppropriateOffset(root: Element, coords: Coords) {\n  if (!coords || !root) {\n    return;\n  }\n\n  // if there's a custom root, then we need to offset by that root's positioning relative to the window\n  // before adjusting for its scroll values\n  if (!isDefaultScrollingElement(root)) {\n    const rootCoords: Coords = getElementCoords(root);\n    return addScrollOffset(root, {\n      x: coords.x - rootCoords.x,\n      y: coords.y - rootCoords.y,\n    });\n  } else {\n    return addScrollOffset(root, coords);\n  }\n}\n\n// apply a common offset calculation where b is centered relative to a. If b is larger than a, the result is that a will be centered within b.\n// b is the moveable element: the returned value will specify where to place b to achieve centering.\nexport function applyCenterOffset(\n  aCoords: Coords,\n  aDims: Dims,\n  b: Dims\n): Coords {\n  return {\n    x: aCoords.x + aDims.width / 2 - b.width / 2,\n    y: aCoords.y + aDims.height / 2 - b.height / 2,\n  };\n}\n\nexport function centerViewportAroundElements(\n  root: Element,\n  a: HTMLElement,\n  b: HTMLElement,\n  aPosition?: Coords,\n  bPosition?: Coords\n): Coords {\n  if (!root || !a || !b) {\n    return;\n  }\n\n  const aCoords = aPosition || getElementCoords(a);\n  const bCoords = bPosition || getElementCoords(b);\n  const aDims = getElementDims(a);\n  const bDims = getElementDims(b);\n  const { coords, dims } = getCombinedData(aCoords, aDims, bCoords, bDims);\n  return centerViewportAround(root, coords, dims);\n}\n\nexport function centerViewportAround(\n  root: Element,\n  coords: Coords,\n  dims: Dims\n): Coords {\n  return applyCenterOffset(coords, dims, getViewportDims(root));\n}\n\n// get the coordinates the viewport would need to be placed for the element to be centered\nexport function centerViewportAroundElement(\n  root: Element,\n  element: HTMLElement\n): Coords {\n  const elementDims: Dims = getElementDims(element);\n  const elementCoords: Coords = getElementCoords(element);\n\n  return centerViewportAround(root, elementCoords, elementDims);\n}\n\n// get the center coord of the viewport. If element is provided, the return value is the origin\n// which would align that element's center with the viewport center. If atViewportPosition is provided,\n// gets the viewport's center at that position\nexport function getViewportCenter(\n  root: Element,\n  element?: HTMLElement,\n  atViewportPosition?: Coords\n): Coords {\n  if (!root) {\n    return;\n  }\n  const startCoords: Coords = atViewportPosition || getViewportStart(root);\n  const viewportDims: Dims = getViewportDims(root);\n  const elementDims: Dims = element\n    ? getElementDims(element)\n    : { height: 0, width: 0 };\n\n  return applyCenterOffset(startCoords, viewportDims, elementDims);\n}\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\n\nimport {\n  Coords,\n  Dims,\n  getElementDims,\n  getNearestScrollAncestor,\n  getTargetInfo,\n  getValidPortalRoot,\n} from '../utils/dom';\nimport { centerViewportAroundElements } from '../utils/offset';\nimport {\n  CardinalOrientation,\n  getTargetPosition,\n  getTooltipPosition,\n  OrientationCoords,\n} from '../utils/positioning';\nimport { scrollToDestination } from '../utils/scroll';\nimport {\n  debounce,\n  getIdString,\n  setFocusTrap,\n  setNextOnTargetClick,\n  setTargetWatcher,\n  setTourUpdateListener,\n  shouldScroll,\n  shouldUpdate,\n} from '../utils/tour';\nimport { Mask, MaskOptions } from './Mask';\nimport { Tooltip } from './Tooltip';\n\nexport interface WalktourLogic {\n  next: (fromTarget?: boolean) => void;\n  prev: () => void;\n  close: (reset?: boolean) => void;\n  goToStep: (stepNumber: number) => void;\n  stepContent: Step;\n  stepIndex: number;\n  allSteps: Step[];\n  tooltipPosition: OrientationCoords;\n}\n\nexport interface WalktourOptions {\n  disableMaskInteraction?: boolean;\n  disableCloseOnClick?: boolean;\n  orientationPreferences?: CardinalOrientation[];\n  maskPadding?: number;\n  maskRadius?: number;\n  maskFill?: string;\n  tooltipSeparation?: number;\n  transition?: string;\n  customTitleRenderer?: (\n    title?: string,\n    tourLogic?: WalktourLogic\n  ) => JSX.Element;\n  customDescriptionRenderer?: (\n    description: string,\n    tourLogic?: WalktourLogic\n  ) => JSX.Element;\n  customFooterRenderer?: (tourLogic?: WalktourLogic) => JSX.Element;\n  customTooltipRenderer?: (tourLogic?: WalktourLogic) => JSX.Element;\n  customNextFunc?: (tourLogic: WalktourLogic, fromTarget?: boolean) => void;\n  customPrevFunc?: (tourLogic: WalktourLogic) => void;\n  customCloseFunc?: (tourLogic: WalktourLogic) => void;\n  prevLabel?: string;\n  nextLabel?: string;\n  closeLabel?: string;\n  disableNext?: boolean;\n  disablePrev?: boolean;\n  disableClose?: boolean;\n  disableAutoScroll?: boolean;\n  getPositionFromCandidates?: (\n    candidates: OrientationCoords[]\n  ) => OrientationCoords;\n  movingTarget?: boolean;\n  updateInterval?: number;\n  renderTolerance?: number;\n  disableMask?: boolean;\n  renderMask?: (maskOptions: MaskOptions) => JSX.Element;\n  disableSmoothScroll?: boolean;\n  allowForeignTarget?: boolean;\n  nextOnTargetClick?: boolean;\n  validateNextOnTargetClick?: () => Promise<boolean>;\n}\n\nexport interface Step extends WalktourOptions {\n  selector: string;\n  title?: string;\n  description: string;\n}\n\nexport interface WalktourProps extends WalktourOptions {\n  steps: Step[];\n  initialStepIndex?: number;\n  zIndex?: number;\n  rootSelector?: string;\n  identifier?: string;\n  setUpdateListener?: (update: () => void) => void;\n  removeUpdateListener?: (update: () => void) => void;\n  disableListeners?: boolean;\n  isOpen?: boolean;\n  debug?: boolean;\n}\n\nconst walktourDefaultProps: Partial<WalktourProps> = {\n  maskPadding: 5,\n  maskRadius: 0,\n  maskFill: 'black',\n  tooltipSeparation: 10,\n  transition: 'top 300ms ease, left 300ms ease',\n  disableMaskInteraction: false,\n  disableCloseOnClick: false,\n  zIndex: 9999,\n  renderTolerance: 2,\n  updateInterval: 500,\n};\n\nconst basePortalString: string = 'walktour-portal';\nconst baseMaskString: string = 'walktour-mask';\nconst baseTooltipContainerString: string = 'walktour-tooltip-container';\n\nexport const Walktour = (props: WalktourProps) => {\n  const { steps, initialStepIndex, isOpen } = props;\n\n  const controlled = isOpen !== undefined;\n  const [isOpenState, setIsOpenState] = React.useState<boolean>(\n    isOpen == undefined\n  );\n  const [target, setTarget] = React.useState<HTMLElement>(undefined);\n  const [tooltipPosition, setTooltipPosition] =\n    React.useState<OrientationCoords>(undefined);\n  const [currentStepIndex, setCurrentStepIndex] = React.useState<number>(\n    initialStepIndex || 0\n  );\n  const [tourRoot, setTourRoot] = React.useState<Element>(undefined);\n\n  const cleanupRefs = React.useRef<Array<() => void>>([]);\n  const tooltip = React.useRef<HTMLElement>(undefined);\n  const portal = React.useRef<HTMLElement>(undefined);\n  const targetPosition = React.useRef<Coords>(undefined);\n  const targetSize = React.useRef<Dims>(undefined);\n\n  const currentStepContent: Step = steps[currentStepIndex];\n  const tourOpen: boolean = controlled ? isOpen : isOpenState;\n\n  const options: WalktourOptions & WalktourProps & Step = {\n    ...walktourDefaultProps,\n    ...props,\n    ...currentStepContent,\n  };\n\n  const {\n    selector,\n    maskPadding,\n    maskRadius,\n    maskFill,\n    disableMaskInteraction,\n    disableCloseOnClick,\n    tooltipSeparation,\n    transition,\n    orientationPreferences,\n    customTooltipRenderer,\n    zIndex,\n    rootSelector,\n    customNextFunc,\n    customPrevFunc,\n    customCloseFunc,\n    disableClose,\n    disableNext,\n    disablePrev,\n    disableAutoScroll,\n    identifier,\n    getPositionFromCandidates,\n    movingTarget,\n    renderTolerance,\n    updateInterval,\n    disableMask,\n    setUpdateListener,\n    removeUpdateListener,\n    disableListeners,\n    disableSmoothScroll,\n    debug,\n    allowForeignTarget,\n    nextOnTargetClick,\n    validateNextOnTargetClick,\n    renderMask,\n  } = options;\n\n  React.useEffect(() => {\n    return cleanup;\n  }, []);\n\n  // set/reset the tour root\n  React.useEffect(() => {\n    let root: Element;\n    if (rootSelector) {\n      root = document.querySelector(rootSelector);\n    }\n    if (!root) {\n      root = getNearestScrollAncestor(portal.current);\n    }\n\n    if (tourOpen !== false && root !== tourRoot) {\n      setTourRoot(root);\n    }\n  }, [rootSelector, portal.current, tourOpen]);\n\n  // update tour when step changes\n  React.useEffect(() => {\n    if (debug) {\n      console.log(\n        `walktour debug (${\n          identifier ? `${identifier}, ` : ''\n        }${currentStepIndex}):`,\n        {\n          'options:': options,\n          'tour logic:': tourLogic,\n          'previous state/vars:': {\n            isOpenState,\n            tourRoot,\n            target,\n            tooltipPosition,\n            targetPosition,\n            currentStepIndex,\n            targetSize,\n          },\n        }\n      );\n    }\n    if (tooltip.current && tourOpen) {\n      tooltip.current.focus();\n      updateTour();\n    } else {\n      cleanup();\n    }\n  }, [\n    currentStepIndex,\n    currentStepContent,\n    tourOpen,\n    tourRoot,\n    tooltip.current,\n  ]);\n\n  // update tooltip and target position in state\n  const updateTour = () => {\n    cleanup();\n    const root: Element = tourRoot;\n    const tooltipContainer: HTMLElement = tooltip.current;\n\n    if (!root || !tooltipContainer) {\n      setTarget(null);\n      setTooltipPosition(null);\n      targetPosition.current = null;\n      targetSize.current = null;\n      return;\n    }\n\n    const targetScope: Element | Document = allowForeignTarget\n      ? document\n      : root;\n    const getTarget = (): HTMLElement => targetScope.querySelector(selector);\n    const currentTarget: HTMLElement = getTarget();\n    const currentTargetPosition: Coords = getTargetPosition(\n      root,\n      currentTarget\n    );\n    const currentTargetDims: Dims = getElementDims(currentTarget);\n    const smartPadding: number = disableMask ? 0 : maskPadding;\n\n    const tooltipPosition: OrientationCoords = getTooltipPosition({\n      target: currentTarget,\n      tooltip: tooltipContainer,\n      padding: smartPadding,\n      tooltipSeparation,\n      orientationPreferences,\n      root,\n      getPositionFromCandidates,\n      disableAutoScroll,\n      allowForeignTarget,\n      selector,\n    });\n\n    setTarget(currentTarget);\n    setTooltipPosition(tooltipPosition);\n    targetPosition.current = currentTargetPosition;\n    targetSize.current = currentTargetDims;\n\n    //focus trap subroutine\n    const cleanupFocusTrap = setFocusTrap(\n      tooltipContainer,\n      currentTarget,\n      disableMaskInteraction\n    );\n    cleanupRefs.current.push(cleanupFocusTrap);\n\n    if (\n      shouldScroll({\n        disableAutoScroll,\n        allowForeignTarget,\n        selector,\n        root,\n        target: currentTarget,\n        tooltip: tooltipContainer,\n        tooltipPosition: tooltipPosition.coords,\n      })\n    ) {\n      scrollToDestination(\n        root,\n        centerViewportAroundElements(\n          root,\n          tooltipContainer,\n          currentTarget,\n          tooltipPosition.coords,\n          currentTargetPosition\n        ),\n        disableSmoothScroll\n      );\n    }\n\n    if (!disableListeners) {\n      const conditionalUpdate = () => {\n        const availableTarget = getTarget();\n\n        if (\n          shouldUpdate({\n            root,\n            tooltipPosition: tooltipPosition.coords,\n            tooltip: tooltipContainer,\n            target: availableTarget,\n            disableAutoScroll,\n            rerenderTolerance: renderTolerance,\n            targetCoords: targetPosition.current,\n            targetDims: targetSize.current,\n            allowForeignTarget,\n            selector,\n            getPositionFromCandidates,\n            orientationPreferences,\n            padding: smartPadding,\n            tooltipSeparation,\n          })\n        ) {\n          updateTour();\n        }\n      };\n\n      const cleanupUpdateListener = setTourUpdateListener({\n        update: debounce(conditionalUpdate),\n        customSetListener: setUpdateListener,\n        customRemoveListener: removeUpdateListener,\n      });\n      cleanupRefs.current.push(cleanupUpdateListener);\n\n      // if the user requests a watcher and there's supposed to be a target\n      if (movingTarget && (currentTarget || selector)) {\n        const cleanupWatcher = setTargetWatcher(\n          conditionalUpdate,\n          updateInterval\n        );\n        cleanupRefs.current.push(cleanupWatcher);\n      }\n\n      if (nextOnTargetClick && currentTarget) {\n        const cleanupTargetTether = setNextOnTargetClick(\n          currentTarget,\n          tourLogic.next,\n          validateNextOnTargetClick\n        );\n        cleanupRefs.current.push(cleanupTargetTether);\n      }\n    }\n  };\n\n  const goToStep = (stepIndex: number) => {\n    if (stepIndex >= steps.length || stepIndex < 0) {\n      return;\n    }\n    setCurrentStepIndex(stepIndex);\n  };\n\n  const cleanup = () => {\n    cleanupRefs.current.forEach(f => f());\n    cleanupRefs.current = [];\n  };\n\n  const closeTour = (reset?: boolean) => {\n    reset && goToStep(0);\n    !controlled && setIsOpenState(false);\n    cleanup();\n    target && target.focus(); // return focus to last target when closed\n  };\n\n  const baseLogic: WalktourLogic = {\n    next: () => goToStep(currentStepIndex + 1),\n    prev: () => goToStep(currentStepIndex - 1),\n    close: (reset?: boolean) => closeTour(reset),\n    goToStep: goToStep,\n    stepContent: { ...options }, //pass options in as well to expose any defaults that aren't specified\n    stepIndex: currentStepIndex,\n    allSteps: steps,\n    tooltipPosition,\n  };\n\n  const tourLogic: WalktourLogic = {\n    ...baseLogic,\n    ...(customNextFunc && {\n      next: (fromTarget?: boolean) => customNextFunc(baseLogic, fromTarget),\n    }),\n    ...(customPrevFunc && { prev: () => customPrevFunc(baseLogic) }),\n    ...(customCloseFunc && { close: () => customCloseFunc(baseLogic) }),\n  };\n\n  const keyPressHandler = (event: React.KeyboardEvent) => {\n    switch (event.key) {\n      case 'Escape':\n        event.preventDefault();\n        if (!disableClose) {\n          tourLogic.close();\n        }\n        break;\n      case 'ArrowRight':\n        event.preventDefault();\n        if (!disableNext) {\n          tourLogic.next();\n        }\n        break;\n      case 'ArrowLeft':\n        event.preventDefault();\n        if (!disablePrev) {\n          tourLogic.prev();\n        }\n        break;\n    }\n  };\n\n  //don't render if the tour is hidden or if there's no step data\n  if (!tourOpen || !currentStepContent) {\n    return null;\n  }\n\n  const portalStyle: React.CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    zIndex: zIndex,\n    visibility: tooltipPosition ? 'visible' : 'hidden',\n    pointerEvents: 'none',\n  };\n\n  const tooltipContainerStyle: React.CSSProperties = {\n    position: 'absolute',\n    top: tooltipPosition?.coords?.y,\n    left: tooltipPosition?.coords?.x,\n    transition: transition,\n    pointerEvents: 'auto',\n  };\n\n  const MaskTag = renderMask ? renderMask : Mask;\n\n  // render mask, tooltip, and their shared \"portal\" container\n  const render = () => (\n    <div\n      ref={ref => (portal.current = ref)}\n      id={getIdString(basePortalString, identifier)}\n      style={portalStyle}\n    >\n      {tourRoot && (\n        <>\n          {!disableMask && (\n            <MaskTag\n              maskId={getIdString(baseMaskString, identifier)}\n              targetInfo={getTargetInfo(tourRoot, target)}\n              disableMaskInteraction={disableMaskInteraction}\n              disableCloseOnClick={disableCloseOnClick}\n              padding={maskPadding}\n              radius={maskRadius}\n              tourRoot={tourRoot}\n              close={tourLogic.close}\n              maskFill={maskFill}\n            />\n          )}\n\n          <div\n            ref={ref => (tooltip.current = ref)}\n            id={getIdString(baseTooltipContainerString, identifier)}\n            style={tooltipContainerStyle}\n            onKeyDown={keyPressHandler}\n            tabIndex={0}\n          >\n            {customTooltipRenderer ? (\n              customTooltipRenderer(tourLogic)\n            ) : (\n              <Tooltip {...tourLogic} />\n            )}\n          </div>\n        </>\n      )}\n    </div>\n  );\n\n  // on first render, put everything in its normal context.\n  // after first render (once we've determined the tour root) spawn a portal there for rendering.\n  if (tourRoot) {\n    return ReactDOM.createPortal(render(), getValidPortalRoot(tourRoot));\n  } else {\n    return render();\n  }\n};\n","import { Coords } from './dom';\nimport { addAppropriateOffset, centerViewportAroundElement } from './offset';\n\nexport function scrollToElement(\n  root: Element,\n  element: HTMLElement,\n  disableSmoothScrolling?: boolean\n): void {\n  if (!root || !element) {\n    return;\n  }\n\n  const coords = addAppropriateOffset(\n    root,\n    centerViewportAroundElement(root, element)\n  );\n\n  scrollToDestination(root, coords, disableSmoothScrolling);\n}\n\nexport function scrollToDestination(\n  root: Element,\n  destination: Coords,\n  disableSmoothScrolling?: boolean\n): void {\n  if (!root || !destination) {\n    return;\n  }\n  // check if the 'scrollBehavior' property is supported. Support for this property is consistent\n  // with support for scrollToOptions, and if it's supported we can scroll smoothly\n  const smoothScrollingIsSupported =\n    'scrollBehavior' in document.documentElement.style;\n  if (smoothScrollingIsSupported && !disableSmoothScrolling) {\n    const scrollOptions: ScrollToOptions = {\n      top: destination.y,\n      left: destination.x,\n      behavior: 'smooth',\n    };\n\n    root.scrollTo(scrollOptions);\n  } else {\n    root.scrollTop = destination.y;\n    root.scrollLeft = destination.x;\n  }\n}\n","import { TAB_KEYCODE } from './constants';\nimport {\n  areaDiff,\n  Coords,\n  Dims,\n  dist,\n  fitsWithin,\n  getEdgeFocusables,\n  getElementDims,\n  isForeignTarget,\n} from './dom';\nimport {\n  getTargetPosition,\n  getTooltipPosition,\n  GetTooltipPositionArgs,\n  OrientationCoords,\n} from './positioning';\nimport { getViewportDims, isElementInView } from './viewport';\n\n//miscellaneous tour utilities\n\nexport function debounce<T extends any[]>(\n  f: (...args: T) => void,\n  interval: number = 300\n) {\n  let timeoutId: number;\n  return (...args: T) => {\n    if (timeoutId) {\n      window.clearTimeout(timeoutId);\n    }\n    timeoutId = window.setTimeout(() => f(...args), interval);\n  };\n}\n\nexport function getIdString(base: string, identifier?: string): string {\n  return `${base}${identifier ? `-${identifier}` : ``}`;\n}\n\nexport function setTargetWatcher(\n  callback: () => void,\n  interval: number\n): () => void {\n  const intervalId: number = window.setInterval(callback, interval);\n\n  return () => window.clearInterval(intervalId);\n}\n\nexport interface SetTourUpdateListenerArgs {\n  update: () => void;\n  customSetListener?: (update: () => void) => void;\n  customRemoveListener?: (update: () => void) => void;\n  event?: string; // default is resize event\n}\n\nexport function setTourUpdateListener(args: SetTourUpdateListenerArgs) {\n  const { update, customSetListener, customRemoveListener, event } = {\n    event: 'resize',\n    ...args,\n  };\n  if (customSetListener && customRemoveListener) {\n    customSetListener(update);\n    return () => customRemoveListener(update);\n  } else {\n    window.addEventListener(event, update);\n    return () => window.removeEventListener(event, update);\n  }\n}\n\ninterface FocusTrapArgs {\n  start: HTMLElement;\n  end: HTMLElement;\n  beforeStart?: HTMLElement;\n  afterEnd?: HTMLElement;\n  // element that should be excluded from the focus trap but may obtain focus.\n  // any focus changes from this element will be directed back to the trap.\n  // behavior is based on \"verify address\" example from https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html\n  lightningRod?: HTMLElement;\n}\n\n// helper function to create a keyboard focus trap, potentially including multiple elements\nfunction getFocusTrapHandler(args: FocusTrapArgs): (e: KeyboardEvent) => void {\n  const { start, end, beforeStart, afterEnd, lightningRod } = args;\n  return (e: KeyboardEvent) => {\n    if (e.keyCode === TAB_KEYCODE) {\n      if (e.shiftKey && e.target === start) {\n        e.preventDefault();\n        beforeStart ? beforeStart.focus() : end.focus();\n      } else if (!e.shiftKey && e.target === end) {\n        e.preventDefault();\n        afterEnd ? afterEnd.focus() : start.focus();\n      } else if (e.target === lightningRod) {\n        e.preventDefault();\n        start.focus();\n      }\n    }\n  };\n}\n\nexport const setFocusTrap = (\n  tooltipContainer: HTMLElement,\n  target?: HTMLElement,\n  disableMaskInteraction?: boolean\n): (() => void) => {\n  if (!tooltipContainer) {\n    return;\n  }\n\n  const { start: tooltipFirst, end: tooltipLast } = getEdgeFocusables(\n    tooltipContainer,\n    tooltipContainer\n  );\n  const { start: targetFirst, end: targetLast } = getEdgeFocusables(\n    undefined,\n    target,\n    true\n  );\n\n  let tooltipBeforeStart: HTMLElement;\n  let tooltipAfterEnd: HTMLElement;\n  let targetTrapHandler: (e: KeyboardEvent) => void;\n\n  if (target && !disableMaskInteraction && targetFirst && targetLast) {\n    tooltipAfterEnd = targetFirst;\n    tooltipBeforeStart = targetLast;\n    targetTrapHandler = getFocusTrapHandler({\n      start: targetFirst,\n      end: targetLast,\n      beforeStart: tooltipLast,\n      afterEnd: tooltipFirst,\n    });\n    target.addEventListener('keydown', targetTrapHandler);\n  }\n\n  const tooltipTrapHandler = getFocusTrapHandler({\n    start: tooltipFirst,\n    end: tooltipLast,\n    beforeStart: tooltipBeforeStart,\n    afterEnd: tooltipAfterEnd,\n    lightningRod: tooltipContainer,\n  });\n  tooltipContainer.addEventListener('keydown', tooltipTrapHandler);\n\n  return () => {\n    if (target) {\n      target.removeEventListener('keydown', targetTrapHandler);\n    }\n\n    tooltipContainer.removeEventListener('keydown', tooltipTrapHandler);\n  };\n};\n\ninterface NaiveShouldScrollArgs {\n  root: Element;\n  tooltip: HTMLElement;\n  tooltipPosition: Coords;\n  target: HTMLElement;\n}\n\nfunction naiveShouldScroll(args: NaiveShouldScrollArgs): boolean {\n  const { root, tooltip, tooltipPosition, target } = args;\n\n  if (!isElementInView(root, tooltip, tooltipPosition)) {\n    return true;\n  }\n\n  if (!isElementInView(root, target)) {\n    return fitsWithin(getElementDims(target), getViewportDims(root));\n  }\n\n  return false;\n}\nexport interface ShouldScrollArgs extends NaiveShouldScrollArgs {\n  disableAutoScroll?: boolean;\n  allowForeignTarget?: boolean;\n  selector?: string;\n}\n\nexport function shouldScroll(args: ShouldScrollArgs): boolean {\n  const {\n    root,\n    tooltip,\n    target,\n    disableAutoScroll,\n    allowForeignTarget,\n    selector: targetSelector,\n  } = args;\n  if (!root || !tooltip || !target) {\n    return false;\n  }\n\n  if (disableAutoScroll) {\n    return false;\n  }\n\n  if (allowForeignTarget && targetSelector) {\n    return !isForeignTarget(root, targetSelector);\n  }\n  return naiveShouldScroll({ ...args });\n}\n\nexport interface TargetChangedArgs {\n  root: Element;\n  target: HTMLElement;\n  targetCoords: Coords;\n  targetDims: Dims;\n  rerenderTolerance: number;\n}\nexport function targetChanged(args: TargetChangedArgs): boolean {\n  const { root, target, targetCoords, targetDims, rerenderTolerance } = args;\n  if (!target && !targetCoords && !targetDims) {\n    return false;\n  }\n\n  // when the target / target data are out of sync. usually due to a movingTarget, i.e. the target arg is more up to date than the pos/dims args\n  if (\n    (!target && targetCoords && targetDims) ||\n    (target && !targetCoords && !targetDims)\n  ) {\n    return true;\n  }\n\n  const currentTargetSize: Dims = getElementDims(target);\n  const currentTargetPosition: Coords = getTargetPosition(root, target);\n\n  const sizeChanged: boolean =\n    areaDiff(currentTargetSize, targetDims) > rerenderTolerance;\n  const positionChanged: boolean =\n    dist(currentTargetPosition, targetCoords) > rerenderTolerance;\n\n  return sizeChanged || positionChanged;\n}\n\nexport interface TooltipDesyncArgs extends GetTooltipPositionArgs {\n  tooltipPosition: Coords;\n}\n\n// if there's no target, we need to ensure that the tooltip is centered, even if the window/container/scroll changes\n// if a target exists, there's not a tooltip desync in this context; there are two other functions\n// to determine if the tooltip/target are out of sync - this is solely for non-target cases\nexport function tooltipDesync(args: TooltipDesyncArgs): boolean {\n  const { target, root, tooltip, tooltipPosition: currentPosition } = args;\n  if (target || !root || !tooltip) {\n    return false;\n  }\n\n  const newPosition: OrientationCoords = getTooltipPosition({ ...args });\n\n  // if there's a difference between the newly calculated position and the current position, we need to update\n  return dist(newPosition.coords, currentPosition) !== 0;\n}\n\nexport interface ShouldUpdateArgs\n  extends TargetChangedArgs,\n    ShouldScrollArgs,\n    TooltipDesyncArgs {}\n\nexport function shouldUpdate(args: ShouldUpdateArgs): boolean {\n  const { root, tooltip } = args;\n  if (!root || !tooltip) {\n    return false; // bail if these aren't present; need them for calculations\n  }\n\n  return (\n    targetChanged({ ...args }) ||\n    shouldScroll({ ...args }) ||\n    tooltipDesync({ ...args })\n  );\n}\n\nexport const takeActionIfValid = async (\n  action: () => void,\n  actionValidator?: () => Promise<boolean>\n) => {\n  if (actionValidator) {\n    const valid: boolean = await actionValidator();\n    if (valid) {\n      action();\n    }\n  } else {\n    action();\n  }\n};\n\nexport const setNextOnTargetClick = (\n  target: HTMLElement,\n  next: (fromTarget?: boolean) => void,\n  validateNext?: () => Promise<boolean>\n): (() => void) => {\n  if (!target) {\n    return;\n  }\n\n  // if valid, call a handler which 1. calls the tetheredAction function and 2. removes itself from the target\n  const clickHandler = () => {\n    const actionWithCleanup = () => {\n      next(true);\n      target.removeEventListener('click', clickHandler);\n    };\n\n    takeActionIfValid(actionWithCleanup, validateNext);\n  };\n\n  target.addEventListener('click', clickHandler);\n  return () => target.removeEventListener('click', clickHandler); // return so we can remove the event elsewhere if the action doesn't get called\n};\n","import * as React from 'react';\n\nimport { defaultStyles, WalktourStyles } from '../defaultstyles';\nimport { WalktourLogic } from './Walktour';\n\ninterface TooltipProps extends WalktourLogic {\n  styles?: WalktourStyles;\n}\n\nexport function Tooltip(props: TooltipProps) {\n  const {\n    next,\n    prev,\n    close,\n    stepContent: {\n      title,\n      description,\n      customTitleRenderer,\n      customDescriptionRenderer,\n      customFooterRenderer,\n      disableClose,\n      disableNext,\n      disablePrev,\n      nextLabel,\n      prevLabel,\n      closeLabel,\n    },\n    stepIndex,\n    allSteps,\n    styles,\n  } = {\n    styles: defaultStyles,\n    ...props,\n  };\n\n  const tooltipStyle: React.CSSProperties = {\n    ...styles.tooltip,\n  };\n\n  const prevDisabled: boolean =\n    disablePrev !== undefined ? disablePrev : stepIndex === 0;\n  const nextDisabled: boolean =\n    disableNext !== undefined ? disableNext : stepIndex + 1 === allSteps.length;\n\n  return (\n    <div style={tooltipStyle}>\n      {customTitleRenderer\n        ? customTitleRenderer(title, props)\n        : title && <div style={styles.title}>{title}</div>}\n\n      {customDescriptionRenderer ? (\n        customDescriptionRenderer(description, props)\n      ) : (\n        <div style={styles.description}>{description}</div>\n      )}\n\n      {customFooterRenderer ? (\n        customFooterRenderer(props)\n      ) : (\n        <div style={styles.footer}>\n          <button\n            onClick={() => close()}\n            style={{\n              ...styles.tertiaryButton,\n              ...(disableClose && styles.disabledButton),\n            }}\n            disabled={disableClose}\n          >\n            {closeLabel || 'close'}\n          </button>\n          <button\n            onClick={prev}\n            disabled={prevDisabled}\n            style={{\n              ...styles.secondaryButton,\n              ...(prevDisabled && styles.disabledButton),\n            }}\n          >\n            {prevLabel || 'prev'}\n          </button>\n          <button\n            onClick={() => next()}\n            disabled={nextDisabled}\n            style={{\n              ...styles.primaryButton,\n              ...(nextDisabled && styles.disabledButton),\n            }}\n          >\n            {nextLabel || 'next'}\n          </button>\n        </div>\n      )}\n    </div>\n  );\n}\n","import { CSSProperties } from 'react';\n\nexport interface WalktourStyles {\n  tooltip: CSSProperties;\n  footer: CSSProperties;\n  title: CSSProperties;\n  description: CSSProperties;\n  primaryButton: CSSProperties;\n  secondaryButton: CSSProperties;\n  tertiaryButton: CSSProperties;\n  disabledButton: CSSProperties;\n}\n\nconst contentMargin: number = 4;\nconst baseButtonStyle: React.CSSProperties = {\n  cursor: 'pointer',\n  padding: '4px 16px',\n  textAlign: 'center',\n  border: 0,\n  borderRadius: 3,\n  backgroundColor: '#0084ff',\n  color: '#fff',\n  fontSize: 14,\n  margin: contentMargin,\n};\n\nexport const defaultStyles: WalktourStyles = {\n  tooltip: {\n    display: 'flex',\n    flexDirection: 'column',\n    zIndex: 9999,\n    fontFamily: 'Roboto, sans-serif',\n    fontSize: 14,\n    backgroundColor: 'white',\n    padding: '10px 10px 5px 10px',\n    borderRadius: '5px',\n    boxShadow: '0 3px 8px 0 rgba(0,0,0,.25)',\n    color: '#4d4d4d',\n    minWidth: 215, //so that buttons have adequate spacing\n    maxWidth: 285,\n  },\n  footer: {\n    display: 'flex',\n    justifyContent: 'center',\n    marginTop: contentMargin,\n  },\n  title: {\n    margin: contentMargin,\n    fontSize: 24,\n  },\n  description: {\n    margin: contentMargin,\n  },\n  primaryButton: {\n    ...baseButtonStyle,\n    backgroundColor: '#0084ff',\n    color: '#ffffff',\n  },\n  secondaryButton: {\n    ...baseButtonStyle,\n    backgroundColor: '#8400ff',\n    color: '#fff',\n    border: 'solid 1px #8400ff',\n  },\n  tertiaryButton: {\n    ...baseButtonStyle,\n    marginRight: 'auto',\n    backgroundColor: `transparent`,\n    color: '#025c53',\n    border: 'solid 1px #025c53',\n  },\n  disabledButton: {\n    ...baseButtonStyle,\n    backgroundColor: '#bebebe',\n    color: '#989898',\n    cursor: 'default',\n  },\n};\n"],"names":[],"version":3,"file":"index.js.map"}